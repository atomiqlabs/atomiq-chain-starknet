import { Provider, constants, Account, WebSocketChannel } from "starknet";
import { StarknetTransactions, StarknetTx } from "./modules/StarknetTransactions";
import { StarknetFees } from "./modules/StarknetFees";
import { StarknetTokens } from "./modules/StarknetTokens";
import { StarknetEvents } from "./modules/StarknetEvents";
import { StarknetSignatures } from "./modules/StarknetSignatures";
import { StarknetAccounts } from "./modules/StarknetAccounts";
import { StarknetBlocks } from "./modules/StarknetBlocks";
import { ChainInterface, TransactionConfirmationOptions } from "@atomiqlabs/base";
import { StarknetSigner } from "../wallet/StarknetSigner";
export type StarknetRetryPolicy = {
    maxRetries?: number;
    delay?: number;
    exponential?: boolean;
};
export type StarknetConfig = {
    getLogChunkSize?: number;
    getLogForwardBlockRange?: number;
    maxGetLogKeys?: number;
    maxParallelCalls?: number;
};
export declare class StarknetChainInterface implements ChainInterface<StarknetTx, StarknetSigner, "STARKNET", Account> {
    readonly chainId = "STARKNET";
    readonly wsChannel?: WebSocketChannel;
    readonly provider: Provider;
    readonly retryPolicy: StarknetRetryPolicy;
    readonly starknetChainId: constants.StarknetChainId;
    Fees: StarknetFees;
    readonly Tokens: StarknetTokens;
    readonly Transactions: StarknetTransactions;
    readonly Signatures: StarknetSignatures;
    readonly Events: StarknetEvents;
    readonly Accounts: StarknetAccounts;
    readonly Blocks: StarknetBlocks;
    protected readonly logger: import("../../utils/Utils").LoggerType;
    readonly config: StarknetConfig;
    constructor(chainId: constants.StarknetChainId, provider: Provider, wsChannel?: WebSocketChannel, retryPolicy?: StarknetRetryPolicy, feeEstimator?: StarknetFees, options?: StarknetConfig);
    getBalance(signer: string, tokenAddress: string): Promise<bigint>;
    getNativeCurrencyAddress(): string;
    isValidToken(tokenIdentifier: string): boolean;
    isValidAddress(address: string, lenient?: boolean): boolean;
    normalizeAddress(address: string): string;
    offBeforeTxReplace(callback: (oldTx: string, oldTxId: string, newTx: string, newTxId: string) => Promise<void>): boolean;
    onBeforeTxReplace(callback: (oldTx: string, oldTxId: string, newTx: string, newTxId: string) => Promise<void>): void;
    onBeforeTxSigned(callback: (tx: StarknetTx) => Promise<void>): void;
    offBeforeTxSigned(callback: (tx: StarknetTx) => Promise<void>): boolean;
    randomAddress(): string;
    randomSigner(): StarknetSigner;
    sendAndConfirm(signer: StarknetSigner, txs: StarknetTx[], waitForConfirmation?: boolean, abortSignal?: AbortSignal, parallel?: boolean, onBeforePublish?: (txId: string, rawTx: string) => Promise<void>): Promise<string[]>;
    serializeTx(tx: StarknetTx): Promise<string>;
    deserializeTx(txData: string): Promise<StarknetTx>;
    getTxIdStatus(txId: string): Promise<"not_found" | "pending" | "success" | "reverted">;
    getTxStatus(tx: string): Promise<"not_found" | "pending" | "success" | "reverted">;
    getFinalizedBlock(): Promise<{
        height: number;
        blockHash: string;
    }>;
    txsTransfer(signer: string, token: string, amount: bigint, dstAddress: string, feeRate?: string): Promise<StarknetTx[]>;
    transfer(signer: StarknetSigner, token: string, amount: bigint, dstAddress: string, txOptions?: TransactionConfirmationOptions): Promise<string>;
    wrapSigner(signer: Account): Promise<StarknetSigner>;
}
